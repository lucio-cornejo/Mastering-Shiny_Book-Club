[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Mastering Shiny Book Club",
    "section": "",
    "text": "Por medio de 5 sesiones prácticas, cada una de dos horas de duración, se explorará en nivel básico el paquete Shiny para crear aplicaciones web vía el lenguaje de programación R.\n\n\n\n\nNivel básico de programación con R.\n\n\n\n\nEstructura básica de la interfaz de usuario creada con Shiny, reactividad básica y creación de dashboards.\n\n\n\nPor medio del paquete Shiny, seremos capaces de crear aplicaciones web que permitan al usuario explorar de manera interactiva los resultados de un proyecto, sea estadístico o de temática más libre.\nAsimismo, este taller servirá para presentar diversos conceptos de desarrollo web, con la finalidad de explorar cómo tales tecnologías pueden potenciar nuestros reportes o dashboards.\n\n\n\nEl taller se realizará de manera virtual, los lunes y miércoles de 7 a 9 pm.\nEn cada sesión, se desarrollarán dos capítulos del libro Mastering Shiny, de libre acceso en línea.\nAl final de cada sesión, se asignará una tarea para los y las estudiantes del taller.\nEn la última sesión, los asistentes que deseen presentarán un proyecto personal elaborado con Shiny.\n\n\n\n\n\n\nUn equipo de R-Ladies guiará a las personas inscritas en el taller, para que puedan instalar las dependencias requeridas para este club de lectura.\n\n\n\n\n\nCapítulo 1: Your first Shiny app\n\nCreación de los componentes básicos de una aplicación Shiny.\nExpresiones reactivas.\n\nCapítulo 2: Basic UI\n\nComponentes principales de la interfaz de usuario.\nComponentes básicos del servidor Shiny.\n\n\n\n\n\n\nCapítulo 3: Basic reactivity\n\nProgramación reactiva.\nControl de la reactividad.\n\nCapítulo 4: Case study: ER injuries\n\nEjemplo práctico donde empleamos las herramientas presentadas hasta ahora.\n\n\n\n\n\n\nCapítulo 6: Layout, themes, HTML\n\nDiseños de una o más páginas.\nPaquete bslib.\n\nCapítulo 9: Uploads and downloads\n\nCarga y descarga de archivos en aplicaciones Shiny.\nReportes parametrizados.\n\n\n\n\n\n\nCapítulo 10: Dynamic UI\n\nActualización de inputs.\nCreación dinámica de contenido en la interfaz de usuario.\n\nCapítulo 15: Reactive building blocks\n\nManipulación de los elementos reactivos en la función servidor.\n\nTiempo libre para consultas y/o para revisión parcial de los proyectos finales por presentar.\n\n\n\n\n\nCreación de dashboards interactivos, vía los paquetes shiny, rmarkdown y flexdashboard.\nIntegración de R y JavaScript, vía el paquete Shiny.\n\n\n\n\n\nEn esta reunión, los asistentes que deseen expondrán aplicaciones Shiny que han llegado a implementar gracias las herramientas expuestas en el taller.\n\n\n\n\n\nLibro principal\nLibro auxiliar\nSolucionario"
  },
  {
    "objectID": "chapter_01.html",
    "href": "chapter_01.html",
    "title": "1  Tu primera aplicación Shiny",
    "section": "",
    "text": "Objetivos:"
  },
  {
    "objectID": "chapter_01.html#qué-es-shiny",
    "href": "chapter_01.html#qué-es-shiny",
    "title": "1  Tu primera aplicación Shiny",
    "section": "1.1 ¿Qué es Shiny?",
    "text": "1.1 ¿Qué es Shiny?\nShiny es una librería para crear aplicaciones web por medio de R o Python, sin necesidad de saber HTML, CSS o JavaScript.\nPese a ello, las aplicaciones Shiny admiten mucha personalización y llegan a aplicarse en contextos académicos (herramienta de enseñanza, presentación de modelos) y no académicos (dashboards interactivos).\nEjemplos de aplicaciones Shiny:\n\nhttps://vivekkatial.shinyapps.io/uber_shiny/#about\nhttps://kneijenhuijs.shinyapps.io/Datify/#section-summary\nhttps://mdubel.shinyapps.io/shark-attack/\nhttps://jennadallen.shinyapps.io/pet-records-app/"
  },
  {
    "objectID": "chapter_01.html#introducción",
    "href": "chapter_01.html#introducción",
    "title": "1  Tu primera aplicación Shiny",
    "section": "1.2 Introducción",
    "text": "1.2 Introducción\n\nComponenetes principales de una aplicación Shiny:\n\nUI: Interfaz de usuario (cómo se ve la app)\nserver(): Función servidor (cómo funciona la app)\n\nInstalemos Shiny usando el siguiente comando en la terminal de R:\n\ninstall.packages(\"shiny\")"
  },
  {
    "objectID": "chapter_01.html#crear-un-directorio-y-archivo-de-la-app",
    "href": "chapter_01.html#crear-un-directorio-y-archivo-de-la-app",
    "title": "1  Tu primera aplicación Shiny",
    "section": "1.3 Crear un directorio y archivo de la app",
    "text": "1.3 Crear un directorio y archivo de la app\n\nForma básica de Shiny app: Documento app.R dentro de algún directorio.\nDentro de app.R, insertar el siguiente código:\n\n# Cargar el paquete Shiny\nlibrary(shiny)\n\n# Definir la interfaz de usuario\nui <- fluidPage(\n  \"Hola, mundo\"\n)\n\n# Definir la interactividad de la app\nserver <- function(input, output, session) {\n}\n\n# Construir y ejecutar la app creada\nshinyApp(ui, server)"
  },
  {
    "objectID": "chapter_01.html#ejecutar-y-detener-la-app",
    "href": "chapter_01.html#ejecutar-y-detener-la-app",
    "title": "1  Tu primera aplicación Shiny",
    "section": "1.4 Ejecutar y detener la app",
    "text": "1.4 Ejecutar y detener la app\n\nPara ejecutar la app, hacer click en el botón Run App de RStudio, o ejecutar shiny::runApp() dentro del directorio que contiene el archivo app.R.\nPara detener la app, hacer click en el botón Stop de RStudio, o presionar Esc o Ctrl+C en la terminal de R."
  },
  {
    "objectID": "chapter_01.html#añadir-controles-a-la-interfaz-de-usuario",
    "href": "chapter_01.html#añadir-controles-a-la-interfaz-de-usuario",
    "title": "1  Tu primera aplicación Shiny",
    "section": "1.5 Añadir controles a la interfaz de usuario",
    "text": "1.5 Añadir controles a la interfaz de usuario\nui <- fluidPage(\n  selectInput(\"dataset\", label = \"Dataset\", choices = ls(\"package:datasets\")),\n  verbatimTextOutput(\"resumen\"),\n  tableOutput(\"tabla\")\n)\n\nfluidPage() es una función de diseño que inicializa todo el HTML, CSS y JavaScript que Shiny requiere.\nselectInput() es un control de input que crea una lista de opciones con la cual el usuario puede interactuar.\nverbatimTextOutput() y tableOutput() son controles de output que fijan en qué sección de la interfaz de usuario se mostrará el resultado/output de tales funciones.\n\nPara explorar las bases de datos que contiene R por default, podemos ejecutar el comando data()."
  },
  {
    "objectID": "chapter_01.html#añadir-reactividad",
    "href": "chapter_01.html#añadir-reactividad",
    "title": "1  Tu primera aplicación Shiny",
    "section": "1.6 Añadir reactividad",
    "text": "1.6 Añadir reactividad\nserver <- function(input, output, session) {\n  output$resumen <- renderPrint({\n    dataset <- get(input$dataset, \"package:datasets\")\n    summary(dataset)\n  })\n  \n  output$tabla <- renderTable({\n    dataset <- get(input$dataset, \"package:datasets\")\n    dataset\n  })\n}\n\nSintaxis común en Shiny:\n\ninput$IDENTIFICADOR\noutput$IDENTIFICADOR\nejemploOutput y renderEjemplo"
  },
  {
    "objectID": "chapter_01.html#expresiones-reactivas",
    "href": "chapter_01.html#expresiones-reactivas",
    "title": "1  Tu primera aplicación Shiny",
    "section": "1.7 Expresiones reactivas",
    "text": "1.7 Expresiones reactivas\n\nCon el fin de evitar repetir código, como se hizo con get(input$dataset, \"package:datasets\"), emplearemos una expresión reactiva.\nLas expresiones reactivas se crean definiendo su código dentro de la expresión reactive({...}).\nLa razón porque Shiny emplea expresiones reactivas, en vez de usar, por ejemplo, variables globales, es que las expresiones reactivas rastrean automáticamente todas sus dependencias. Es decir, si una expresión reactiva Y depende de algún valor X, cualquier cambio en X automáticamente actualiza el valor de la expresión Y.\n\nserver <- function(input, output, session) {\n  # Creamos una expresión reactiva\n  dataset <- reactive({\n    get(input$dataset, \"package:datasets\")\n  })\n\n  output$resumen <- renderPrint({\n    # Usamos la expresión reactiva como si fuese una función\n    summary(dataset())\n  })\n  \n  output$tabla <- renderTable({\n    dataset()\n  })\n}"
  },
  {
    "objectID": "chapter_01.html#resumen",
    "href": "chapter_01.html#resumen",
    "title": "1  Tu primera aplicación Shiny",
    "section": "1.8 Resumen",
    "text": "1.8 Resumen\n\nChuleta de Shiny"
  },
  {
    "objectID": "chapter_01.html#ejercicios",
    "href": "chapter_01.html#ejercicios",
    "title": "1  Tu primera aplicación Shiny",
    "section": "1.9 Ejercicios",
    "text": "1.9 Ejercicios\nHacer los ejercicios 2, 3 y 4."
  },
  {
    "objectID": "chapter_01.html#extra",
    "href": "chapter_01.html#extra",
    "title": "1  Tu primera aplicación Shiny",
    "section": "1.10 Extra",
    "text": "1.10 Extra\n\nGalería de Shiny.\nExtensiones de Shiny.\nshinyuieditor. Instalación"
  },
  {
    "objectID": "chapter_02.html",
    "href": "chapter_02.html",
    "title": "2  Interfaz básica de usuario",
    "section": "",
    "text": "Objetivos:"
  },
  {
    "objectID": "chapter_02.html#introducción",
    "href": "chapter_02.html#introducción",
    "title": "2  Interfaz básica de usuario",
    "section": "2.1 Introducción",
    "text": "2.1 Introducción\nRecordemos que la UI (interfaz de usuario) de la aplicación Shiny se encarga del frontend de nuestra app, y que la función servidor (server) define el backend de la apliación.\nEn este capítulo, nos enfocaremos en la interfaz de usuario."
  },
  {
    "objectID": "chapter_02.html#inputs",
    "href": "chapter_02.html#inputs",
    "title": "2  Interfaz básica de usuario",
    "section": "2.2 Inputs",
    "text": "2.2 Inputs\n\n2.2.1 Estructura común\n\nfuncionInput(inputId = \"\", ...)\nEl identificador conecta el frontend (ui) con el backend (server).\nEl identificador debe ser único en la app.\nEl identificador debe ser una cadena de texto (character) que solo puede contener letras, números y guiones bajos.\nEjemplo:\nsliderInput(\"min\", label = \"Límite (mínimo)\", value = 50, min = 0, max = 100)\n\nMás ejemplos\n\n\n2.2.2 Texto libre\nui <- fluidPage(\n  textInput(\"ejemplo1\", \"¿Cómo te llamas?\"),\n  passwordInput(\"ejemplo2\", \"¿Cuál es tu contraseña?\"),\n  textAreaInput(\"ejemplo3\", \"Cuéntame sobre ti ...\", rows = 3)\n)\n\n\n2.2.3 Inputs numéricos\nPara adquirir valores numéricos, tenemos dos opciones: numericInput() y sliderInput().\nui <- fluidPage(\n  numericInput(\"ejemplo1\", \"Número uno\", value = 0, min = 0, max = 100),\n  sliderInput(\"ejemplo2\", \"Número dos\", value = 50, min = 0, max = 100),\n  sliderInput(\"ejemplo3\", \"Rango\", value = c(10, 20), min = 0, max = 100)\n)\nIncluso es posible hacer animaciones con tales sliders.\n\n\n2.2.4 Fechas\nui <- fluidPage(\n  # Adquiere una fecha\n  dateInput(\"ejemplo1\", \"¿Cuándo naciste?\"),\n  # Adquiere un rango de fechas\n  dateRangeInput(\"ejemplo2\", \"¿Cuándo son tus vacaciones?\")\n)\n\n\n2.2.5 Lista de opciones\n\nTenemos varias alternativas:\n\nselectInput(): Permite seleccionar más de una opción.\nradioButtons(): Solo una opción seleccionable.\ncheckboxGroupInput(): Permite seleccionar más de una opción.\ncheckboxInput(): Solo una opción seleccionable.\n\n\nanimales <- c(\"Perro\", \"Gato\", \"Ratón\", \"Odio a los animales\")\n\nui <- fluidPage(\n  selectInput(\"ejemplo1\", \"¿Cuál es tu estado favorito de EEUU?\", state.name),\n  selectInput(\n    \"ejemplo2\", \"¿Cuál es tu estado favorito de EEUU?\", \n    state.name, multiple = TRUE\n  ),\n  \n  radioButtons(\"ejemplo3\", \"¿Cuál es tu animal favorito?\", animales),\n\n  checkboxGroupInput(\"ejemplo4\", \"¿Qué animales no odias?\", animales),\n  checkboxInput(\"ejemplo5\", \"¿Se entiende?\", value = TRUE),\n  checkboxInput(\"ejemplo6\", \"¿Muchos ejemplos ya?\")\n)\n\n\n2.2.6 Cargar archivos\n\nEsta opción es muy útil para la creación de reportes parametrizados, pero la exploraremos con mayor detalle en la sesión 3.\n\nui <- fluidPage(\n  fileInput(\"carga\", NULL)\n)\n\n\n2.2.7 Botones de acción\n\nEl uso no trivial de los botones de acción, actionButton() y actionLink(), requerirá conocer las funciones observeEvent() or eventReactive(), asociadas a la función servidor.\n\nui <- fluidPage(\n  fluidRow(\n    actionButton(\"ejemplo1\", \"¡Presiona aquí!\", class = \"btn-success\"),\n    actionLink(\"ejemplo2\", \"¿Aguita?\", icon = icon(\"cocktail\"))\n  ),\n  fluidRow(\n    actionButton(\n      \"ejemplo3\", \n      class = c(\"btn-danger\", \"btn-block\"),\n      label = \"¡¡ERES NUESTRO VISITANTE 1.000.000!!\"\n    )\n  )\n)\nChuleta de opciones de Bootstrap para class = \"\"."
  },
  {
    "objectID": "chapter_02.html#outputs",
    "href": "chapter_02.html#outputs",
    "title": "2  Interfaz básica de usuario",
    "section": "2.3 Outputs",
    "text": "2.3 Outputs\n\n2.3.1 Texto\n\ntextOutput(), junto con renderText({}), se emplean para imprimir texto estándar (cadenas de caracteres).\nverbatimTextOutput(), junto con renderPrint({}), se usa cuando se requiere imprimir el resultado (textual) del código dentro de renderPrint.\nLas llaves {} se utilizan para incluir más de una línea de código dentro de, por ejemplo, renderText({}), sin necesidad de usar comas como hemos estado haciendo para fluidPage().\n\nui <- fluidPage(\n  textOutput(\"texto\"),\n  verbatimTextOutput(\"codigo\")\n)\n\nserver <- function(input, output, session) {\n  output$texto <- renderText(\"Hola, buenas.\")\n  output$codigo <- renderPrint({\n    \"Hola, buenas.\"\n  })\n}\n\n\n2.3.2 Tablas\n\ntableOutput() y renderTable() se emplean para imprimir tablas en su totalidad. Resultado estático.\ndataTableOutput() y renderDataTable() sirven para mostrar solo una parte del total de filas de la tabla, además de permitir cambiar qué filas mostrar. Resultado dinámico.\n\nui <- fluidPage(\n  tableOutput(\"estatico\"),\n  dataTableOutput(\"dinamico\")\n)\nserver <- function(input, output, session) {\n  output$estatico <- renderTable(head(mtcars))\n  output$dinamico <- renderDataTable(mtcars, options = list(pageLength = 5))\n}\n\n\n2.3.3 Gráficos\nPara los gráficos fundamentales de R (plot(), ggplot(), etc), se emplea plotOutput() y renderPlot().\nui <- fluidPage(\n  plotOutput(\"grafico\", width = \"400px\")\n)\nserver <- function(input, output, session) {\n  output$grafico <- renderPlot(\n    plot(1:5), \n    # Resolucion del gráfico, en píxeles por pulgada\n    res = 96\n  )\n}\n\n\n2.3.4 Descargas\nEsto lo exploraremos en la tercera sesión.\n\n\n2.3.5 Resumen\n\nChuleta de Shiny widgets\n\n\n\n2.3.6 Ejercicios\n\nTodos los ejercicios de esta sección."
  },
  {
    "objectID": "chapter_03.html",
    "href": "chapter_03.html",
    "title": "3  Reactividad básica",
    "section": "",
    "text": "Objetivos:"
  },
  {
    "objectID": "chapter_03.html#introducción",
    "href": "chapter_03.html#introducción",
    "title": "3  Reactividad básica",
    "section": "3.1 Introducción",
    "text": "3.1 Introducción\nEn Shiny, la lógica de la función servidor se define usando programación reactiva. El principio fundamenteal de este tipo de programación consiste en especificar un grafo de dependencias, de manera que, cuando algún input cambie, todos sus outputs asociados se actualicen automáticamente."
  },
  {
    "objectID": "chapter_03.html#la-función-servidor-server",
    "href": "chapter_03.html#la-función-servidor-server",
    "title": "3  Reactividad básica",
    "section": "3.2 La función servidor (server)",
    "text": "3.2 La función servidor (server)\n\nCuando corremos una aplicación Shiny, Shiny ejecuta la función servidor.\nAl ejecutarse la función servidor, se aislan las variables dentro de tal función, y, se crea una sesión (session) única a la instancia donde se está ejecutando la aplicación.\nDicha ejecución permite que la interacción de un usuario A, con una aplicación Shiny X, no afecte al estado de la aplicación X cuando está siendo utilizada por otro usuario B.\n\n\n3.2.1 input\n\nEl argumento input contiene la información que manda el navegador web, sobre la data de los inputs en la aplicación, en función de su identificador.\ninput$IDENTIFICADOR es el valor del input con identificador IDENTIFICADOR.\ninput es como una lista de R, pero no podemos modificar su contenido, dentro de la función servidor.\nPara leer a algún valor del argumento input, esta lectura debe realizarse dentro de un contexto reactivo, tales como renderText() y reactive().\n\nlibrary(shiny)\n\nui <- fluidPage(\n  numericInput(\"n\", label = \"Cantidad de valores\", value = 100)\n)\n\nserver <- function(input, output, session) {\n  # Incorrecto\n  # input$n <- 10  \n\n  # Incorrecto x2\n  message(\"The value of input$n is \", input$n)\n\n}\n\nshinyApp(ui, server)\n\n\n3.2.2 output\n\nAsí como el parámetro input, ouput es un objeto parecido a una lista de R, a cuyos elementos se accede vía los identificadores de output.\nSiempre se usa el parámetro output junto a alguna función de tipo render.\n\nEjemplo:\nui <- fluidPage(\n  textOutput(\"saludo\")\n)\n\nserver <- function(input, output, session) {\n  # Incorrecto\n  output$saludo <- \"Hola, buenas.\"\n  \n  # Incorrecto x2\n  message(\"El mensaje es \", output$saludo)\n  \n  # Correcto\n  output$saludo <- renderText(\"Hola, buenas.\")\n}\n¿Qué hace una función de tipo render?\n\nCrea un contexto reactivo que automáticamente rastrea qué inputs emplea aquel output.\nConvierte el resultado de su código de R, a HTML apropiado para actualizar el contenido de la página.\n\n\n\n3.2.3 Programación reactiva\nEjemplo de la actualización automática que nos proporciona la programación reactiva de Shiny:\nui <- fluidPage(\n  textInput(\"nombre\", \"¿Y tú cómo te llamas?\"),\n  textOutput(\"saludo\")\n)\n\nserver <- function(input, output, session) {\n  output$saludo <- renderText({\n    paste0(\"¡Hola \", input$nombre, \"!\")\n  })\n}\nLa magia de Shiny consiste en que no necesitas avisar a un output cuándo debe actualizarse, ya que Shiny lo resuelve por ti.\n¿Pero cómo funciona el código en server?\n\nEl código incluido en la función servidor no se ejecuta al momento de correr la aplicación.\nDepende totalmente de Shiny, cuándo es que ese código va a ejecutarse, o si se ejecuta, incluso.\nEs como si, en la función servidor, nosotros proveemos recetas a Shiny, en vez de asignarle comandos.\n\n¿A qué nos referimos con recetas y comandos?\n\n3.2.3.1 Programación imperativa vs programación declarativa\n\nProgramación imperativa:\n\nDefines un comando y este se ejecuta inmediatamente.\nR es un lenguaje imperativo.\n\nProgramación declarativa:\n\nDescribes qué hacer cuando ciertas condiciones se cumplan, pero tú no decides cuándo se ejecutan tales instrucciones.\nShiny emplea este estilo de programación.\n\n\nEjemplo del libro:\n\nCódigo imperativo: “Hazme un sánguche.”\nCódigo declarativo: **“Asegúrate que haya un sánguche en la refrigeradora cuando yo mire dentro de esta.”\n\n\n\n3.2.3.2 Pereza\nLas aplicaciones Shiny son extremadamente perezosas, en el sentido que Shiny no ejecutará el código de las secciones output que no sean parte de la aplicación.\nEjemplo:\nui <- fluidPage(\n  textInput(\"nombre\", \"¿Y tú cómo te llamas?\"),\n  textOutput(\"saludo\")\n)\n\nserver <- function(input, output, session) {\n  output$saluda <- renderText({\n    paste0(\"¡Hola \", input$nombre, \"!\")\n  })\n}\n\n\n3.2.3.3 El gráfico reactivo\nLa pereza de Shiny también se manifiesta en que el código en la función servidor no se ejecuta de arriba a abajo, como es la manera convencional en R, sino más bien cuando sea necesario.\nPara entender cuándo es necesario que Shiny ejecute código, se trabaja con el gráfico reactivo, una visualización que describe cómo los inputs y outputs están relacionados.\n\n\n\n\nflowchart LR\n  A[nombre] ===> B{Saludo}\n\n  linkStyle 0 stroke-width:5px, fill: green, stroke:blue;\n\n\n\n\n\n\n\n\n\nEl gráfico reactivo contiene un símbolo por cada input y output.\nCada input se conecta a todo output que acceda al valor de tal input.\nEl gráfico reactivo sirve para saber cómo funciona la app creada.\n\n\n\n3.2.3.4 Expresiones reactivas\nA las expresiones reactivas las denotaremos con un símbolo especial en el gráfico reactivo. Estas sirven para reducir la repetición de código dentro de la función servidor.\nui <- fluidPage(\n  textInput(\"nombre\", \"¿Y tú cómo te llamas?\"),\n  textOutput(\"saludo\")\n)\n\nserver <- function(input, output, session) {\n  cadena <- reactive(paste0(\"¡Hola \", input$nombre, \"!\"))\n  output$saludo <- renderText(cadena())\n}\n\n\n\n\nflowchart LR\n  A[nombre] ===> B(cadena)\n  B(cadena) ===> C{saludo}\n\n  linkStyle 0 stroke-width:5px, fill: green, stroke:blue;\n  linkStyle 1 stroke-width:5px, fill: green, stroke:blue;\n\n\n\n\n\n\n\n\n\n\n3.2.3.5 Orden de ejecución\nEl siguiente ejemplo parece no debería funcionar, pero la pereza de Shiny permite que la aplicación funcione, ya que el gráfico reactivo de esta app no ha cambiado, por lo que el orden en que se ejecuta el código es el mismo.\nui <- fluidPage(\n  textInput(\"nombre\", \"¿Y tú cómo te llamas?\"),\n  textOutput(\"saludo\")\n)\n\nserver <- function(input, output, session) {\n  output$saludo <- renderText(cadena())\n  cadena <- reactive(paste0(\"¡Hola \", input$nombre, \"!\"))\n}\n\n\n3.2.3.6 Ejercicios\n\nEn clase, solo hacer el ejercicio 1.\nLos ejercicios 2 y 3 son tarea.\n\n\n\n\n3.2.4 Expresiones reactivas\n\nEstas son útiles porque proporcionan a Shiny más información, para que se ejecute menos veces el mismo código (de R), una vez que las inputs cambian, mejorando así la eficiencia de la aplicación Shiny.\nTambién sirven para simplificar el gráfico de reactividad.\n\nRecordemos que las expresiones reactivas dependen de inputs y saben automáticamente cuando actualizarse. Asimismo, podemos usar el valor de expresiones reactivas dentro de un output.\n\n3.2.4.1 La motivación\nRealizaremos una simulación donde emplearemos la función t.test() para determinar si la media de dos grupos de datos son iguales.\nPero, supondremos que ambos grupos de datos han sido sorteados de distribuciones normales (gaussianas) con misma desviación estándar.\nEn caso que el p-valor hallado vía el t.test() resulte menor que 0.05, entonces afirmaremos que las medias de las distribuciones son diferentes.\nlibrary(ggplot2)\n\nfreqpoly <- function(x1, x2, binwidth = 0.1, xlim = c(-3, 3)) {\n  df <- data.frame(\n    x = c(x1, x2),\n    g = c(rep(\"x1\", length(x1)), rep(\"x2\", length(x2)))\n  )\n\n  ggplot(df, aes(x, colour = g)) +\n    geom_freqpoly(binwidth = binwidth, size = 1) +\n    coord_cartesian(xlim = xlim)\n}\n\nt_test <- function(x1, x2) {\n  test <- t.test(x1, x2)\n  \n  sprintf(\n    \"p valor: %0.3f\\n[%0.2f, %0.2f]\",\n    test$p.value, test$conf.int[1], test$conf.int[2]\n  )\n}\nx1 <- rnorm(100, mean = 0, sd = 1)\nx2 <- rnorm(200, mean = 0.1, sd = 1)\n\nfreqpoly(x1, x2)\ncat(t_test(x1, x2))\n\n\n3.2.4.2 La aplicación\nEn vez de ejecutar las simulaciones cambiando parámetros en el código, y ejecutar de nuevo el código relevante, podemos acelerar este proceso por medio de una aplicación Shiny.\nui <- fluidPage(\n  fluidRow(\n    column(4, \n      \"Distribución 1\",\n      numericInput(\"n1\", label = \"n\", value = 1000, min = 1),\n      numericInput(\"mean1\", label = \"µ\", value = 0, step = 0.1)\n    ),\n    column(4, \n      \"Distribución 2\",\n      numericInput(\"n2\", label = \"n\", value = 1000, min = 1),\n      numericInput(\"mean2\", label = \"µ\", value = 0, step = 0.1)\n    ),\n    column(4,\n      \"Polígono de frecuencias\",\n      numericInput(\"binwidth\", label = \"Bin width\", value = 0.1, step = 0.1),\n      sliderInput(\"range\", label = \"range\", value = c(-3, 3), min = -5, max = 5)\n    )\n  ),\n  fluidRow(\n    column(9, plotOutput(\"hist\")),\n    column(3, verbatimTextOutput(\"ttest\"))\n  )\n)\n\nserver <- function(input, output, session) {\n  output$hist <- renderPlot({\n    x1 <- rnorm(input$n1, input$mean1, 1)\n    x2 <- rnorm(input$n2, input$mean2, 1)\n    \n    freqpoly(x1, x2, binwidth = input$binwidth, xlim = input$range)\n  }, res = 96)\n\n  output$ttest <- renderText({\n    x1 <- rnorm(input$n1, input$mean1, 1)\n    x2 <- rnorm(input$n2, input$mean2, 1)\n    \n    t_test(x1, x2)\n  })\n}\n\n\n3.2.4.3 El gráfico reactivo\nShiny sabe que debe actualiza un output solo cuando los inputs a los que hace referencia cambian de valor.\nSin embargo, Shiny no ejecuta solo parte del código dentro de contexto reactivo, es decir, o ejecuta todo ese bloque de código, o no ejecuta nada.\nEjemplo:\nx1 <- rnorm(input$n1, input$mean1, 1)\nx2 <- rnorm(input$n2, input$mean2, 1)\n\nt_test(x1, x2)\nVer su gráfico reactivo (parecido).\nFallas:\n\nLa aplicación es ineficiente, hace más trabajo de lo necesario; por ejemplo, al alterar bindwidth.\nSu gráfico reactivo es difícil de entender.\nEl error principal es que el gráfico y t.test están evaluando data distinta, debido a su naturaleza aleatoria. Debe tratarse de la misma data en ambos contextos reactivos.\n\n(Cambiar Bin width o range manualmente)\n\n\n3.2.4.4 Simplificando el gráfico\nserver <- function(input, output, session) {\n  x1 <- reactive(rnorm(input$n1, input$mean1, 1))\n  x2 <- reactive(rnorm(input$n2, input$mean2, 1))\n\n  output$hist <- renderPlot({\n    freqpoly(x1(), x2(), binwidth = input$binwidth, xlim = input$range)\n  }, res = 96)\n\n  output$ttest <- renderText({\n    t_test(x1(), x2())\n  })\n}\n(Cambiar Bin width o range manualmente)\nVer el nuevo gráfico reactivo (parecido).\n\n\n3.2.4.5 ¿Por qué necesitamos expresiones reactivas?\nSe podría intentar reemplazar el uso de expresiones reactivas, en favor de variables o funciones usuales como las empleamos en R. Sin embargo, ambos casos o fallarán o serán ineficientes.\nUso de variables\nserver <- function(input, output, session) {\n  x1 <- rnorm(input$n1, input$mean1, 1)\n  x2 <- rnorm(input$n2, input$mean2, 1)\n  output$hist <- renderPlot({\n    freqpoly(x1, x2, binwidth = input$binwidth, xlim = input$range)\n  }, res = 96)\n\n  output$ttest <- renderText({\n    t_test(x1, x2)\n  })\n}\nErrores:\n\nIntentar acceder a valores de input, fuera de un contexto reactivo.\nx1 <-  ... y x2 <-  ... solo se ejecutaría una vez, cuando empieza la sesión.\n\nUso de funciones\nserver <- function(input, output, session) { \n  x1 <- function() rnorm(input$n1, input$mean1, 1)\n  x2 <- function() rnorm(input$n2, input$mean2, 1)\n\n  output$hist <- renderPlot({\n    freqpoly(x1(), x2(), binwidth = input$binwidth, xlim = input$range)\n  }, res = 96)\n\n  output$ttest <- renderText({\n    t_test(x1(), x2())\n  })\n}\nCon este método, la app va a funcionar, pero cada input que cambie hará que se ejecute todo el código de la función servidor, una vez más. En realidad, es el mismo problema que tuvimos en la sección El gráfico reactivo.\nRecuerden que las expresiones reactivas automáticamente guardan su valor, y solo se actualizan cuando sus inputs cambian de valor."
  },
  {
    "objectID": "chapter_03.html#controlando-el-tiempo-de-evaluación",
    "href": "chapter_03.html#controlando-el-tiempo-de-evaluación",
    "title": "3  Reactividad básica",
    "section": "3.3 Controlando el tiempo de evaluación",
    "text": "3.3 Controlando el tiempo de evaluación\nTodavía no exploraremos las herramientas de esta sección, ya que serán presentadas como parte del capítulo 15, durante la sesión 4.\n\n3.3.1 reactiveTimer()\nVer app_04 de capítulo 3 (simulación automática).\n\n\n3.3.2 On click\nVer app_05 de capítulo 3 (simulación pausada)."
  },
  {
    "objectID": "chapter_03.html#observeevent",
    "href": "chapter_03.html#observeevent",
    "title": "3  Reactividad básica",
    "section": "3.4 observeEvent()",
    "text": "3.4 observeEvent()\nLa función observeEvent() cuenta con dos argumentos: - El primero, es el input que servirá de dependencia. - El segundo, es el código que se ejecutará cuando el input señalado cambie de valor.\nlibrary(shiny)\n\nui <- fluidPage(\n  textInput(\"nombre\", \"¿Cuál es tu nombre?\"),\n  textOutput(\"saludo\")\n)\n\nserver <- function(input, output, session) {\n  cadena <- reactive(paste0(\"Hola \", input$nombre))\n  \n  output$saludo <- renderText(cadena())\n  observeEvent(input$nombre, {\n    message(\"Saludo realizado\")\n  })\n}\n\nshinyApp(ui, server)\nEsta función nos servirá al momento de integrar R con JavaScript.\nVer ejemplo en carpeta session_example.\nEste capítulo concluye la visión general de Shiny."
  },
  {
    "objectID": "chapter_03.html#extra",
    "href": "chapter_03.html#extra",
    "title": "3  Reactividad básica",
    "section": "3.5 Extra",
    "text": "3.5 Extra\n\nGuía , por parte del creador de Shiny, sobre cómo programar de manera eficiente en Shiny.\nFunción t.test() de R."
  }
]