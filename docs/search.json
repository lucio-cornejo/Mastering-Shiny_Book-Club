[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Mastering Shiny Book Club",
    "section": "",
    "text": "Por medio de 5 sesiones prácticas, cada una de dos horas de duración, se explorará en nivel básico el paquete Shiny para crear aplicaciones web vía el lenguaje de programación R.\n\n\n\n\nNivel básico de programación con R.\n\n\n\n\nEstructura básica de la interfaz de usuario creada con Shiny, reactividad básica y creación de dashboards.\n\n\n\nPor medio del paquete Shiny, seremos capaces de crear aplicaciones web que permitan al usuario explorar de manera interactiva los resultados de un proyecto, sea estadístico o de temática más libre.\nAsimismo, este taller servirá para presentar diversos conceptos de desarrollo web, con la finalidad de explorar cómo tales tecnologías pueden potenciar nuestros reportes o dashboards.\n\n\n\nEl taller se realizará de manera virtual, los lunes y miércoles de 7 a 9 pm.\nEn cada sesión, se desarrollarán dos capítulos del libro Mastering Shiny, de libre acceso en línea.\nAl final de cada sesión, se asignará una tarea para los y las estudiantes del taller.\nEn la última sesión, los asistentes que deseen presentarán un proyecto personal elaborado con Shiny.\n\n\n\n\n\n\nUn equipo de R-Ladies guiará a las personas inscritas en el taller, para que puedan instalar las dependencias requeridas para este club de lectura.\n\n\n\n\n\nCapítulo 1: Your first Shiny app\n\nCreación de los componentes básicos de una aplicación Shiny.\nExpresiones reactivas.\n\nCapítulo 2: Basic UI\n\nComponentes principales de la interfaz de usuario.\nComponentes básicos del servidor Shiny.\n\n\n\n\n\n\nCapítulo 3: Basic reactivity\n\nProgramación reactiva.\nControl de la reactividad.\n\nCapítulo 4: Case study: ER injuries\n\nEjemplo práctico donde se emplean las herramientas presentadas hasta ahora.\nLa tarea de esta sesión es crear la aplicación de este capítulo.\n\n\n\n\n\n\nCapítulo 6: Layout, themes, HTML\n\nDiseños de una o más páginas.\nPaquete bslib.\n\nCapítulo 9: Uploads and downloads\n\nCarga y descarga de archivos en aplicaciones Shiny.\nReportes parametrizados.\n\n\n\n\n\n\nCapítulo 10: Dynamic UI\n\nActualización de inputs.\nCreación dinámica de contenido en la interfaz de usuario.\n\nCapítulo 15: Reactive building blocks\n\nManipulación de los elementos reactivos en la función servidor.\n\nTiempo libre para consultas y/o para revisión parcial de los proyectos finales por presentar.\n\n\n\n\n\nCreación de dashboards interactivos, vía los paquetes shiny, rmarkdown y flexdashboard.\nIntegración de R y JavaScript, vía el paquete Shiny.\n\n\n\n\n\nEn esta reunión, los asistentes que deseen expondrán aplicaciones Shiny que han llegado a implementar gracias las herramientas expuestas en el taller.\n\n\n\n\n\nLibro principal\nLibro auxiliar\nSolucionario"
  },
  {
    "objectID": "chapter_01.html",
    "href": "chapter_01.html",
    "title": "1  Tu primera aplicación Shiny",
    "section": "",
    "text": "Objetivos:"
  },
  {
    "objectID": "chapter_01.html#qué-es-shiny",
    "href": "chapter_01.html#qué-es-shiny",
    "title": "1  Tu primera aplicación Shiny",
    "section": "1.1 ¿Qué es Shiny?",
    "text": "1.1 ¿Qué es Shiny?\nShiny es una librería para crear aplicaciones web por medio de R o Python, sin necesidad de saber HTML, CSS o JavaScript.\nPese a ello, las aplicaciones Shiny admiten mucha personalización y llegan a aplicarse en contextos académicos (herramienta de enseñanza, presentación de modelos) y no académicos (dashboards interactivos).\nEjemplos de aplicaciones Shiny:\n\nhttps://vivekkatial.shinyapps.io/uber_shiny/#about\nhttps://kneijenhuijs.shinyapps.io/Datify/#section-summary\nhttps://mdubel.shinyapps.io/shark-attack/\nhttps://jennadallen.shinyapps.io/pet-records-app/"
  },
  {
    "objectID": "chapter_01.html#introducción",
    "href": "chapter_01.html#introducción",
    "title": "1  Tu primera aplicación Shiny",
    "section": "1.2 Introducción",
    "text": "1.2 Introducción\n\nComponenetes principales de una aplicación Shiny:\n\nUI: Interfaz de usuario (cómo se ve la app)\nserver(): Función servidor (cómo funciona la app)\n\nInstalemos Shiny usando el siguiente comando en la terminal de R:\n\ninstall.packages(\"shiny\")"
  },
  {
    "objectID": "chapter_01.html#crear-un-directorio-y-archivo-de-la-app",
    "href": "chapter_01.html#crear-un-directorio-y-archivo-de-la-app",
    "title": "1  Tu primera aplicación Shiny",
    "section": "1.3 Crear un directorio y archivo de la app",
    "text": "1.3 Crear un directorio y archivo de la app\n\nForma básica de Shiny app: Documento app.R dentro de algún directorio.\nDentro de app.R, insertar el siguiente código:\n\n# Cargar el paquete Shiny\nlibrary(shiny)\n\n# Definir la interfaz de usuario\nui <- fluidPage(\n  \"Hola, mundo\"\n)\n\n# Definir la interactividad de la app\nserver <- function(input, output, session) {\n}\n\n# Construir y ejecutar la app creada\nshinyApp(ui, server)"
  },
  {
    "objectID": "chapter_01.html#ejecutar-y-detener-la-app",
    "href": "chapter_01.html#ejecutar-y-detener-la-app",
    "title": "1  Tu primera aplicación Shiny",
    "section": "1.4 Ejecutar y detener la app",
    "text": "1.4 Ejecutar y detener la app\n\nPara ejecutar la app, hacer click en el botón Run App de RStudio, o ejecutar shiny::runApp() dentro del directorio que contiene el archivo app.R.\nPara detener la app, hacer click en el botón Stop de RStudio, o presionar Esc o Ctrl+C en la terminal de R."
  },
  {
    "objectID": "chapter_01.html#añadir-controles-a-la-interfaz-de-usuario",
    "href": "chapter_01.html#añadir-controles-a-la-interfaz-de-usuario",
    "title": "1  Tu primera aplicación Shiny",
    "section": "1.5 Añadir controles a la interfaz de usuario",
    "text": "1.5 Añadir controles a la interfaz de usuario\nui <- fluidPage(\n  selectInput(\"dataset\", label = \"Dataset\", choices = ls(\"package:datasets\")),\n  verbatimTextOutput(\"resumen\"),\n  tableOutput(\"tabla\")\n)\n\nfluidPage() es una función de diseño que inicializa todo el HTML, CSS y JavaScript que Shiny requiere.\nselectInput() es un control de input que crea una lista de opciones con la cual el usuario puede interactuar.\nverbatimTextOutput() y tableOutput() son controles de output que fijan en qué sección de la interfaz de usuario se mostrará el resultado/output de tales funciones.\n\nPara explorar las bases de datos que contiene R por default, podemos ejecutar el comando data()."
  },
  {
    "objectID": "chapter_01.html#añadir-reactividad",
    "href": "chapter_01.html#añadir-reactividad",
    "title": "1  Tu primera aplicación Shiny",
    "section": "1.6 Añadir reactividad",
    "text": "1.6 Añadir reactividad\nserver <- function(input, output, session) {\n  output$resumen <- renderPrint({\n    dataset <- get(input$dataset, \"package:datasets\")\n    summary(dataset)\n  })\n  \n  output$tabla <- renderTable({\n    dataset <- get(input$dataset, \"package:datasets\")\n    dataset\n  })\n}\n\nSintaxis común en Shiny:\n\ninput$IDENTIFICADOR\noutput$IDENTIFICADOR\nejemploOutput y renderEjemplo"
  },
  {
    "objectID": "chapter_01.html#expresiones-reactivas",
    "href": "chapter_01.html#expresiones-reactivas",
    "title": "1  Tu primera aplicación Shiny",
    "section": "1.7 Expresiones reactivas",
    "text": "1.7 Expresiones reactivas\n\nCon el fin de evitar repetir código, como se hizo con get(input$dataset, \"package:datasets\"), emplearemos una expresión reactiva.\nLas expresiones reactivas se crean definiendo su código dentro de la expresión reactive({...}).\nLa razón porque Shiny emplea expresiones reactivas, en vez de usar, por ejemplo, variables globales, es que las expresiones reactivas rastrean automáticamente todas sus dependencias. Es decir, si una expresión reactiva Y depende de algún valor X, cualquier cambio en X automáticamente actualiza el valor de la expresión Y.\n\nserver <- function(input, output, session) {\n  # Creamos una expresión reactiva\n  dataset <- reactive({\n    get(input$dataset, \"package:datasets\")\n  })\n\n  output$resumen <- renderPrint({\n    # Usamos la expresión reactiva como si fuese una función\n    summary(dataset())\n  })\n  \n  output$tabla <- renderTable({\n    dataset()\n  })\n}"
  },
  {
    "objectID": "chapter_01.html#resumen",
    "href": "chapter_01.html#resumen",
    "title": "1  Tu primera aplicación Shiny",
    "section": "1.8 Resumen",
    "text": "1.8 Resumen\n\nChuleta de Shiny"
  },
  {
    "objectID": "chapter_01.html#ejercicios",
    "href": "chapter_01.html#ejercicios",
    "title": "1  Tu primera aplicación Shiny",
    "section": "1.9 Ejercicios",
    "text": "1.9 Ejercicios\nHacer los ejercicios 2, 3 y 4."
  },
  {
    "objectID": "chapter_01.html#extra",
    "href": "chapter_01.html#extra",
    "title": "1  Tu primera aplicación Shiny",
    "section": "1.10 Extra",
    "text": "1.10 Extra\n\nGalería de Shiny.\nExtensiones de Shiny.\nshinyuieditor. Instalación"
  },
  {
    "objectID": "chapter_02.html",
    "href": "chapter_02.html",
    "title": "2  Interfaz básica de usuario",
    "section": "",
    "text": "Objetivos:"
  },
  {
    "objectID": "chapter_02.html#introducción",
    "href": "chapter_02.html#introducción",
    "title": "2  Interfaz básica de usuario",
    "section": "2.1 Introducción",
    "text": "2.1 Introducción\nRecordemos que la UI (interfaz de usuario) de la aplicación Shiny se encarga del frontend de nuestra app, y que la función servidor (server) define el backend de la apliación.\nEn este capítulo, nos enfocaremos en la interfaz de usuario."
  },
  {
    "objectID": "chapter_02.html#inputs",
    "href": "chapter_02.html#inputs",
    "title": "2  Interfaz básica de usuario",
    "section": "2.2 Inputs",
    "text": "2.2 Inputs\n\n2.2.1 Estructura común\n\nfuncionInput(inputId = \"\", ...)\nEl identificador conecta el frontend (ui) con el backend (server).\nEl identificador debe ser único en la app.\nEl identificador debe ser una cadena de texto (character) que solo puede contener letras, números y guiones bajos.\nEjemplo:\nsliderInput(\"min\", label = \"Límite (mínimo)\", value = 50, min = 0, max = 100)\n\nMás ejemplos\n\n\n2.2.2 Texto libre\nui <- fluidPage(\n  textInput(\"ejemplo1\", \"¿Cómo te llamas?\"),\n  passwordInput(\"ejemplo2\", \"¿Cuál es tu contraseña?\"),\n  textAreaInput(\"ejemplo3\", \"Cuéntame sobre ti ...\", rows = 3)\n)\n\n\n2.2.3 Inputs numéricos\nPara adquirir valores numéricos, tenemos dos opciones: numericInput() y sliderInput().\nui <- fluidPage(\n  numericInput(\"ejemplo1\", \"Número uno\", value = 0, min = 0, max = 100),\n  sliderInput(\"ejemplo2\", \"Número dos\", value = 50, min = 0, max = 100),\n  sliderInput(\"ejemplo3\", \"Rango\", value = c(10, 20), min = 0, max = 100)\n)\nIncluso es posible hacer animaciones con tales sliders.\n\n\n2.2.4 Fechas\nui <- fluidPage(\n  # Adquiere una fecha\n  dateInput(\"ejemplo1\", \"¿Cuándo naciste?\"),\n  # Adquiere un rango de fechas\n  dateRangeInput(\"ejemplo2\", \"¿Cuándo son tus vacaciones?\")\n)\n\n\n2.2.5 Lista de opciones\n\nTenemos varias alternativas:\n\nselectInput(): Permite seleccionar más de una opción.\nradioButtons(): Solo una opción seleccionable.\ncheckboxGroupInput(): Permite seleccionar más de una opción.\ncheckboxInput(): Solo una opción seleccionable.\n\n\nanimales <- c(\"Perro\", \"Gato\", \"Ratón\", \"Odio a los animales\")\n\nui <- fluidPage(\n  selectInput(\"ejemplo1\", \"¿Cuál es tu estado favorito de EEUU?\", state.name),\n  selectInput(\n    \"ejemplo2\", \"¿Cuál es tu estado favorito de EEUU?\", \n    state.name, multiple = TRUE\n  ),\n  \n  radioButtons(\"ejemplo3\", \"¿Cuál es tu animal favorito?\", animales),\n\n  checkboxGroupInput(\"ejemplo4\", \"¿Qué animales no odias?\", animales),\n  checkboxInput(\"ejemplo5\", \"¿Se entiende?\", value = TRUE),\n  checkboxInput(\"ejemplo6\", \"¿Muchos ejemplos ya?\")\n)\n\n\n2.2.6 Cargar archivos\n\nEsta opción es muy útil para la creación de reportes parametrizados, pero la exploraremos con mayor detalle en la sesión 3.\n\nui <- fluidPage(\n  fileInput(\"carga\", NULL)\n)\n\n\n2.2.7 Botones de acción\n\nEl uso no trivial de los botones de acción, actionButton() y actionLink(), requerirá conocer las funciones observeEvent() or eventReactive(), asociadas a la función servidor.\n\nui <- fluidPage(\n  fluidRow(\n    actionButton(\"ejemplo1\", \"¡Presiona aquí!\", class = \"btn-success\"),\n    actionLink(\"ejemplo2\", \"¿Aguita?\", icon = icon(\"cocktail\"))\n  ),\n  fluidRow(\n    actionButton(\n      \"ejemplo3\", \n      class = c(\"btn-danger\", \"btn-block\"),\n      label = \"¡¡ERES NUESTRO VISITANTE 1.000.000!!\"\n    )\n  )\n)\nChuleta de opciones de Bootstrap para class = \"\"."
  },
  {
    "objectID": "chapter_02.html#outputs",
    "href": "chapter_02.html#outputs",
    "title": "2  Interfaz básica de usuario",
    "section": "2.3 Outputs",
    "text": "2.3 Outputs\n\n2.3.1 Texto\n\ntextOutput(), junto con renderText({}), se emplean para imprimir texto estándar (cadenas de caracteres).\nverbatimTextOutput(), junto con renderPrint({}), se usa cuando se requiere imprimir el resultado (textual) del código dentro de renderPrint.\nLas llaves {} se utilizan para incluir más de una línea de código dentro de, por ejemplo, renderText({}), sin necesidad de usar comas como hemos estado haciendo para fluidPage().\n\nui <- fluidPage(\n  textOutput(\"texto\"),\n  verbatimTextOutput(\"codigo\")\n)\n\nserver <- function(input, output, session) {\n  output$texto <- renderText(\"Hola, buenas.\")\n  output$codigo <- renderPrint({\n    \"Hola, buenas.\"\n  })\n}\n\n\n2.3.2 Tablas\n\ntableOutput() y renderTable() se emplean para imprimir tablas en su totalidad. Resultado estático.\ndataTableOutput() y renderDataTable() sirven para mostrar solo una parte del total de filas de la tabla, además de permitir cambiar qué filas mostrar. Resultado dinámico.\n\nui <- fluidPage(\n  tableOutput(\"estatico\"),\n  dataTableOutput(\"dinamico\")\n)\nserver <- function(input, output, session) {\n  output$estatico <- renderTable(head(mtcars))\n  output$dinamico <- renderDataTable(mtcars, options = list(pageLength = 5))\n}\n\n\n2.3.3 Gráficos\nPara los gráficos fundamentales de R (plot(), ggplot(), etc), se emplea plotOutput() y renderPlot().\nui <- fluidPage(\n  plotOutput(\"grafico\", width = \"400px\")\n)\nserver <- function(input, output, session) {\n  output$grafico <- renderPlot(\n    plot(1:5), \n    # Resolucion del gráfico, en píxeles por pulgada\n    res = 96\n  )\n}\n\n\n2.3.4 Descargas\nEsto lo exploraremos en la tercera sesión.\n\n\n2.3.5 Resumen\n\nChuleta de Shiny widgets\n\n\n\n2.3.6 Ejercicios\n\nTodos los ejercicios de esta sección."
  },
  {
    "objectID": "chapter_02.html#video-de-la-sesión",
    "href": "chapter_02.html#video-de-la-sesión",
    "title": "2  Interfaz básica de usuario",
    "section": "2.4 Video de la sesión",
    "text": "2.4 Video de la sesión"
  },
  {
    "objectID": "chapter_03.html",
    "href": "chapter_03.html",
    "title": "3  Reactividad básica",
    "section": "",
    "text": "Objetivos:"
  },
  {
    "objectID": "chapter_03.html#introducción",
    "href": "chapter_03.html#introducción",
    "title": "3  Reactividad básica",
    "section": "3.1 Introducción",
    "text": "3.1 Introducción\nEn Shiny, la lógica de la función servidor se define usando programación reactiva. El principio fundamenteal de este tipo de programación consiste en especificar un grafo de dependencias, de manera que, cuando algún input cambie, todos sus outputs asociados se actualicen automáticamente."
  },
  {
    "objectID": "chapter_03.html#la-función-servidor-server",
    "href": "chapter_03.html#la-función-servidor-server",
    "title": "3  Reactividad básica",
    "section": "3.2 La función servidor (server)",
    "text": "3.2 La función servidor (server)\n\nCuando corremos una aplicación Shiny, Shiny ejecuta la función servidor.\nAl ejecutarse la función servidor, se aislan las variables dentro de tal función, y, se crea una sesión (session) única a la instancia donde se está ejecutando la aplicación.\nDicha ejecución permite que la interacción de un usuario A, con una aplicación Shiny X, no afecte al estado de la aplicación X cuando está siendo utilizada por otro usuario B.\n\n\n3.2.1 input\n\nEl argumento input contiene la información que manda el navegador web, sobre la data de los inputs en la aplicación, en función de su identificador.\ninput$IDENTIFICADOR es el valor del input con identificador IDENTIFICADOR.\ninput es como una lista de R, pero no podemos modificar su contenido, dentro de la función servidor.\nPara leer a algún valor del argumento input, esta lectura debe realizarse dentro de un contexto reactivo, tales como renderText() y reactive().\n\nlibrary(shiny)\n\nui <- fluidPage(\n  numericInput(\"n\", label = \"Cantidad de valores\", value = 100)\n)\n\nserver <- function(input, output, session) {\n  # Incorrecto\n  # input$n <- 10  \n\n  # Incorrecto x2\n  message(\"The value of input$n is \", input$n)\n\n}\n\nshinyApp(ui, server)\n\n\n3.2.2 output\n\nAsí como el parámetro input, ouput es un objeto parecido a una lista de R, a cuyos elementos se accede vía los identificadores de output.\nSiempre se usa el parámetro output junto a alguna función de tipo render.\n\nEjemplo:\nui <- fluidPage(\n  textOutput(\"saludo\")\n)\n\nserver <- function(input, output, session) {\n  # Incorrecto\n  output$saludo <- \"Hola, buenas.\"\n  \n  # Incorrecto x2\n  message(\"El mensaje es \", output$saludo)\n  \n  # Correcto\n  output$saludo <- renderText(\"Hola, buenas.\")\n}\n¿Qué hace una función de tipo render?\n\nCrea un contexto reactivo que automáticamente rastrea qué inputs emplea aquel output.\nConvierte el resultado de su código de R, a HTML apropiado para actualizar el contenido de la página.\n\n\n\n3.2.3 Programación reactiva\nEjemplo de la actualización automática que nos proporciona la programación reactiva de Shiny:\nui <- fluidPage(\n  textInput(\"nombre\", \"¿Y tú cómo te llamas?\"),\n  textOutput(\"saludo\")\n)\n\nserver <- function(input, output, session) {\n  output$saludo <- renderText({\n    paste0(\"¡Hola \", input$nombre, \"!\")\n  })\n}\nLa magia de Shiny consiste en que no necesitas avisar a un output cuándo debe actualizarse, ya que Shiny lo resuelve por ti.\n¿Pero cómo funciona el código en server?\n\nEl código incluido en la función servidor no se ejecuta al momento de correr la aplicación.\nDepende totalmente de Shiny, cuándo es que ese código va a ejecutarse, o si se ejecuta, incluso.\nEs como si, en la función servidor, nosotros proveemos recetas a Shiny, en vez de asignarle comandos.\n\n¿A qué nos referimos con recetas y comandos?\n\n3.2.3.1 Programación imperativa vs programación declarativa\n\nProgramación imperativa:\n\nDefines un comando y este se ejecuta inmediatamente.\nR es un lenguaje imperativo.\n\nProgramación declarativa:\n\nDescribes qué hacer cuando ciertas condiciones se cumplan, pero tú no decides cuándo se ejecutan tales instrucciones.\nShiny emplea este estilo de programación.\n\n\nEjemplo del libro:\n\nCódigo imperativo: “Hazme un sánguche.”\nCódigo declarativo: **“Asegúrate que haya un sánguche en la refrigeradora cuando yo mire dentro de esta.”\n\n\n\n3.2.3.2 Pereza\nLas aplicaciones Shiny son extremadamente perezosas, en el sentido que Shiny no ejecutará el código de las secciones output que no sean parte de la aplicación.\nEjemplo:\nui <- fluidPage(\n  textInput(\"nombre\", \"¿Y tú cómo te llamas?\"),\n  textOutput(\"saludo\")\n)\n\nserver <- function(input, output, session) {\n  output$saluda <- renderText({\n    paste0(\"¡Hola \", input$nombre, \"!\")\n  })\n}\n\n\n3.2.3.3 El gráfico reactivo\nLa pereza de Shiny también se manifiesta en que el código en la función servidor no se ejecuta de arriba a abajo, como es la manera convencional en R, sino más bien cuando sea necesario.\nPara entender cuándo es necesario que Shiny ejecute código, se trabaja con el gráfico reactivo, una visualización que describe cómo los inputs y outputs están relacionados.\n\n\n\n\nflowchart LR\n  A[nombre] ===> B>Saludo]\n\n  linkStyle 0 stroke-width:5px, fill: green, stroke:blue;\n\n\n\n\n\n\n\n\n\nEl gráfico reactivo contiene un símbolo por cada input y output.\nCada input se conecta a todo output que acceda al valor de tal input.\nEl gráfico reactivo sirve para saber cómo funciona la app creada.\n\n\n\n3.2.3.4 Expresiones reactivas\nA las expresiones reactivas las denotaremos con un símbolo especial en el gráfico reactivo. Estas sirven para reducir la repetición de código dentro de la función servidor.\nui <- fluidPage(\n  textInput(\"nombre\", \"¿Y tú cómo te llamas?\"),\n  textOutput(\"saludo\")\n)\n\nserver <- function(input, output, session) {\n  cadena <- reactive(paste0(\"¡Hola \", input$nombre, \"!\"))\n  output$saludo <- renderText(cadena())\n}\n\n\n\n\nflowchart LR\n  A[nombre] ===> B((cadena))\n  B((cadena)) ===> C>saludo]\n\n  linkStyle 0 stroke-width:5px, fill: green, stroke:blue;\n  linkStyle 1 stroke-width:5px, fill: green, stroke:blue;\n\n\n\n\n\n\n\n\n\n\n3.2.3.5 Orden de ejecución\nEl siguiente ejemplo parece no debería funcionar, pero la pereza de Shiny permite que la aplicación funcione, ya que el gráfico reactivo de esta app no ha cambiado, por lo que el orden en que se ejecuta el código es el mismo.\nui <- fluidPage(\n  textInput(\"nombre\", \"¿Y tú cómo te llamas?\"),\n  textOutput(\"saludo\")\n)\n\nserver <- function(input, output, session) {\n  output$saludo <- renderText(cadena())\n  cadena <- reactive(paste0(\"¡Hola \", input$nombre, \"!\"))\n}\n\n\n3.2.3.6 Ejercicios\n\nEn clase, solo hacer el ejercicio 1.\nLos ejercicios 2 y 3 son tarea.\n\n\n\n\n3.2.4 Expresiones reactivas\n\nEstas son útiles porque proporcionan a Shiny más información, para que se ejecute menos veces el mismo código (de R), una vez que las inputs cambian, mejorando así la eficiencia de la aplicación Shiny.\nTambién sirven para simplificar el gráfico de reactividad.\n\nRecordemos que las expresiones reactivas dependen de inputs y saben automáticamente cuando actualizarse. Asimismo, podemos usar el valor de expresiones reactivas dentro de un output.\n\n3.2.4.1 La motivación\nRealizaremos una simulación donde emplearemos la función t.test() para determinar si la media de dos grupos de datos son iguales.\nPero, supondremos que ambos grupos de datos han sido sorteados de distribuciones normales (gaussianas) con misma desviación estándar.\nEn caso que el p-valor hallado vía el t.test() resulte menor que 0.05, entonces afirmaremos que las medias de las distribuciones son diferentes.\nlibrary(ggplot2)\n\nfreqpoly <- function(x1, x2, binwidth = 0.1, xlim = c(-3, 3)) {\n  df <- data.frame(\n    x = c(x1, x2),\n    g = c(rep(\"x1\", length(x1)), rep(\"x2\", length(x2)))\n  )\n\n  ggplot(df, aes(x, colour = g)) +\n    geom_freqpoly(binwidth = binwidth, size = 1) +\n    coord_cartesian(xlim = xlim)\n}\n\nt_test <- function(x1, x2) {\n  test <- t.test(x1, x2)\n  \n  sprintf(\n    \"p valor: %0.3f\\n[%0.2f, %0.2f]\",\n    test$p.value, test$conf.int[1], test$conf.int[2]\n  )\n}\nx1 <- rnorm(100, mean = 0, sd = 1)\nx2 <- rnorm(200, mean = 0.1, sd = 1)\n\nfreqpoly(x1, x2)\ncat(t_test(x1, x2))\n\n\n3.2.4.2 La aplicación\nEn vez de ejecutar las simulaciones cambiando parámetros en el código, y ejecutar de nuevo el código relevante, podemos acelerar este proceso por medio de una aplicación Shiny.\nui <- fluidPage(\n  fluidRow(\n    column(4, \n      \"Distribución 1\",\n      numericInput(\"n1\", label = \"n\", value = 1000, min = 1),\n      numericInput(\"mean1\", label = \"µ\", value = 0, step = 0.1)\n    ),\n    column(4, \n      \"Distribución 2\",\n      numericInput(\"n2\", label = \"n\", value = 1000, min = 1),\n      numericInput(\"mean2\", label = \"µ\", value = 0, step = 0.1)\n    ),\n    column(4,\n      \"Polígono de frecuencias\",\n      numericInput(\"binwidth\", label = \"Bin width\", value = 0.1, step = 0.1),\n      sliderInput(\"range\", label = \"range\", value = c(-3, 3), min = -5, max = 5)\n    )\n  ),\n  fluidRow(\n    column(9, plotOutput(\"hist\")),\n    column(3, verbatimTextOutput(\"ttest\"))\n  )\n)\n\nserver <- function(input, output, session) {\n  output$hist <- renderPlot({\n    x1 <- rnorm(input$n1, input$mean1, 1)\n    x2 <- rnorm(input$n2, input$mean2, 1)\n    \n    freqpoly(x1, x2, binwidth = input$binwidth, xlim = input$range)\n  }, res = 96)\n\n  output$ttest <- renderText({\n    x1 <- rnorm(input$n1, input$mean1, 1)\n    x2 <- rnorm(input$n2, input$mean2, 1)\n    \n    t_test(x1, x2)\n  })\n}\n\n\n3.2.4.3 El gráfico reactivo\nShiny sabe que debe actualiza un output solo cuando los inputs a los que hace referencia cambian de valor.\nSin embargo, Shiny no ejecuta solo parte del código dentro de contexto reactivo, es decir, o ejecuta todo ese bloque de código, o no ejecuta nada.\nEjemplo:\nx1 <- rnorm(input$n1, input$mean1, 1)\nx2 <- rnorm(input$n2, input$mean2, 1)\n\nt_test(x1, x2)\n\n\n\n\nflowchart LR\n  A[n1] --> B>ttest]\n  C[mean1] --> B>ttest]\n  D[n2] --> B>ttest]\n  E[mean2] --> B>ttest]\n  \n  A[n1] --> G>ttest]\n  C[mean1] --> G>ttest]\n  D[n2] --> G>ttest]\n  E[mean2] --> G>ttest]\n  F[binwidth] --> G>hist]\n  H[range] --> G>hist]\n\n  linkStyle 4 stroke:red;\n  linkStyle 5 stroke:red;\n  linkStyle 6 stroke:red;\n  linkStyle 7 stroke:red;\n  linkStyle 8 stroke:red;\n  linkStyle 9 stroke:red;\n\n  linkStyle default stroke-width:2px, fill:none, stroke:blue;\n\n\n\n\n\n\n\n\nFallas:\n\nLa aplicación es ineficiente, hace más trabajo de lo necesario; por ejemplo, al alterar bindwidth.\nSu gráfico reactivo es difícil de entender.\nEl error principal es que el gráfico y t.test están evaluando data distinta, debido a su naturaleza aleatoria. Debe tratarse de la misma data en ambos contextos reactivos.\n\n(Cambiar Bin width o range manualmente)\n\n\n3.2.4.4 Simplificando el gráfico\nserver <- function(input, output, session) {\n  x1 <- reactive(rnorm(input$n1, input$mean1, 1))\n  x2 <- reactive(rnorm(input$n2, input$mean2, 1))\n\n  output$hist <- renderPlot({\n    freqpoly(x1(), x2(), binwidth = input$binwidth, xlim = input$range)\n  }, res = 96)\n\n  output$ttest <- renderText({\n    t_test(x1(), x2())\n  })\n}\n(Cambiar Bin width o range manualmente)\n\n\n\n\nflowchart LR\n  A[n1] --> X((x1))\n  B[mean1] --> X((x1))\n\n  C[n2] --> Y((x2))\n  D[mean2] --> Y((x2))\n  \n  E[binwidth] --> W>hist]\n  F[range] --> W>hist]\n  \n  X((x1)) --> V>ttest]\n  X((x1)) --> W>hist]\n\n  Y((x2)) --> V>ttest]\n  Y((x2)) --> W>hist]\n\n\n  linkStyle default stroke-width:2px, fill:none, stroke:blue;\n\n\n\n\n\n\n\n\n\n\n3.2.4.5 ¿Por qué necesitamos expresiones reactivas?\nSe podría intentar reemplazar el uso de expresiones reactivas, en favor de variables o funciones usuales como las empleamos en R. Sin embargo, ambos casos o fallarán o serán ineficientes.\nUso de variables\nserver <- function(input, output, session) {\n  x1 <- rnorm(input$n1, input$mean1, 1)\n  x2 <- rnorm(input$n2, input$mean2, 1)\n  output$hist <- renderPlot({\n    freqpoly(x1, x2, binwidth = input$binwidth, xlim = input$range)\n  }, res = 96)\n\n  output$ttest <- renderText({\n    t_test(x1, x2)\n  })\n}\nErrores:\n\nIntentar acceder a valores de input, fuera de un contexto reactivo.\nx1 <-  ... y x2 <-  ... solo se ejecutaría una vez, cuando empieza la sesión.\n\nUso de funciones\nserver <- function(input, output, session) { \n  x1 <- function() rnorm(input$n1, input$mean1, 1)\n  x2 <- function() rnorm(input$n2, input$mean2, 1)\n\n  output$hist <- renderPlot({\n    freqpoly(x1(), x2(), binwidth = input$binwidth, xlim = input$range)\n  }, res = 96)\n\n  output$ttest <- renderText({\n    t_test(x1(), x2())\n  })\n}\nCon este método, la app va a funcionar, pero cada input que cambie hará que se ejecute todo el código de la función servidor, una vez más. En realidad, es el mismo problema que tuvimos en la sección El gráfico reactivo.\nRecuerden que las expresiones reactivas automáticamente guardan su valor, y solo se actualizan cuando sus inputs cambian de valor."
  },
  {
    "objectID": "chapter_03.html#control-del-tiempo-de-evaluación",
    "href": "chapter_03.html#control-del-tiempo-de-evaluación",
    "title": "3  Reactividad básica",
    "section": "3.3 Control del tiempo de evaluación",
    "text": "3.3 Control del tiempo de evaluación\nTodavía no exploraremos las herramientas de esta sección, ya que serán presentadas como parte del capítulo 15, durante la sesión 4.\n\n3.3.1 reactiveTimer()\nCódigo del ejemplo del libro (simulación automática).\n\n\n3.3.2 On click\nCódigo del ejemplo del libro (simulación pausada)."
  },
  {
    "objectID": "chapter_03.html#observeevent",
    "href": "chapter_03.html#observeevent",
    "title": "3  Reactividad básica",
    "section": "3.4 observeEvent()",
    "text": "3.4 observeEvent()\nNo es necesario que, al correr una app Shiny, cambiar el valor de algún input actualice el contenido de la página.\nSi requerimos que cierto código (no asociado a algún output) se ejecute cuando cierto input en particular cambie de valor, podemos usar la función observeEvent() … esta cuenta con dos argumentos:\n\nEl primero, es el input que servirá de dependencia.\nEl segundo, es el código que se ejecutará cuando el input señalado cambie de valor.\n\nlibrary(shiny)\n\nui <- fluidPage(\n  textInput(\"nombre\", \"¿Cuál es tu nombre?\"),\n  textOutput(\"saludo\")\n)\n\nserver <- function(input, output, session) {\n  cadena <- reactive(paste0(\"Hola \", input$nombre))\n  \n  output$saludo <- renderText(cadena())\n  observeEvent(input$nombre, {\n    message(\"Saludo realizado\")\n  })\n}\n\nshinyApp(ui, server)\nSimilarmente, si requerimos que cierto código (no asociado a algún output) se ejecute cuando uno o más inputs en particular cambie(n) de valor, podemos usar la función observe().\nLas funciones observe() y observeEvent() nos servirán al momento de integrar R con JavaScript.\nPueden ver un ejemplo de aquella interacción, vía el código en esta carpeta.\nEste capítulo concluye la visión general de Shiny."
  },
  {
    "objectID": "chapter_03.html#extra",
    "href": "chapter_03.html#extra",
    "title": "3  Reactividad básica",
    "section": "3.5 Extra",
    "text": "3.5 Extra\n\nGuía, por parte del creador de Shiny, sobre cómo programar de manera eficiente en Shiny.\nFunción t.test() de R."
  },
  {
    "objectID": "chapter_03.html#tarea",
    "href": "chapter_03.html#tarea",
    "title": "3  Reactividad básica",
    "section": "3.6 Tarea",
    "text": "3.6 Tarea\n\nRealizar los ejercicios 2 y 3 de esta sección.\nCompletar el capítulo 4 del libro Mastering Shiny."
  },
  {
    "objectID": "chapter_03.html#video-de-la-sesión",
    "href": "chapter_03.html#video-de-la-sesión",
    "title": "3  Reactividad básica",
    "section": "3.7 Video de la sesión",
    "text": "3.7 Video de la sesión"
  },
  {
    "objectID": "chapter_06.html",
    "href": "chapter_06.html",
    "title": "\n4  Diseño, temas y HTML\n",
    "section": "",
    "text": "Al final de esta sección, habremos logrado lo siguiente:\n\nAprender sobre cómo organizar los inputs y outputs de una app Shiny.\nMejorar la apariencia de una aplicación Shiny, por medio de Bootstrap.\nFamiliarizarnos con HTML y CSS, para poder personalizar a detalle nuestras aplicaciones web.\n\n\nPara el diseño de las aplicaciones Shiny, la jerarquía de las funciones empleadas para definir la interfaz de usuario coincide con la jerarquía de los elementos que aquel código produce para la página web.\nEjemplo:\nfluidPage(\n  titlePanel(\"Título\")),\n  sidebarLayout(\n    sidebarPanel(\n      sliderInput(\"obs\", \"Observaciones:\", min = 0, max = 1000, value = 500)\n    ),\n    mainPanel(\n      plotOutput(\"histograma\")\n    )\n  )\n)\nNotemos la jerarquía del siguiente código, y del resultado HTML que produce cuando lo evaluamos en la consola de R.\n(añadir título)\nfluidPage(\n  titlePanel(\"\"),\n  sidebarLayout(\n    sidebarPanel(),\n    mainPanel()\n  )\n)\n\nLa función de diseño más importante para Shiny es fluidPage(). Aquella función sirve también para inicializar el HTML, CSS y JavaScript que requiere nuestra aplicación Shiny.\nComparemos el código HTML de las siguientes aplicaciones elementales:\nlibrary(shiny)\n\nui <- fluidPage(\n)\n\nserver <- function(input, output) {\n}\n\n# Caso 1: Sin fluidPage()\nshinyApp(NULL, server)\n\n# Caso 2: Con fluidPage()\n# shinyApp(ui, server)\n\n# Presione Ctrl+U tras visualizar la app en un navegador web.\nOtras maneras de inicializar la interfaz de usuario:\n\n\nfixedPage()\n\nParecido a fluidPage(), pero fija un máximo de ancho para la página, ya sea 940 pixeles (px), 724px o 1170px, dependiendo del tamaño de la pantalla.\nRequiere el uso de fixedRow() en vez de fluidRow().\n\n\n\nfillPage()\n\nSirve para limitarnos a emplear la altura completa del navegador donde se visualiza la app.\nRequiere el uso de fillRow() en vez de fluidRow().\n\n\n\nEl uso de una barra lateral nos permite organizar de manera separada y más ordenada los inputs y outputs de la aplicación Shiny.\nEstructura básica:\nfluidPage(\n  titlePanel(\n    # Título o descripción de la apppp\n  ),\n  sidebarLayout(\n    sidebarPanel(\n      # inputs\n    ),\n    mainPanel(\n      # outputs\n    )\n  )\n)\n\n\n\n\n\n\n\n\nEjemplo: Demo del teorema del límite central\nlibrary(shiny)\n\nui <- fluidPage(\n  titlePanel(\"Teorema del Límite Central\")),\n  sidebarLayout(\n    sidebarPanel(\n      numericInput(\"m\", \"Tamaño de las muestras:\"\",22, min==11, max==100))\n    ),\n    mainPanel(\n      plotOutput(\"hist\")\n    )\n  )\n)\nserver <- function(input, output, session) {\n  output$hist <- renderPlot({\n    medias <- replicate(1e4, mean(runif(input$m)))\n    hist(medias, breaks = 20, main = \"Histograma de las medias\")\n  }, res = 96)\n}\n\nshinyApp(ui, server)\n\nShiny nos permite estructurar el contenido de la interfaz de usuario, en forma de filas y columnas.\nEjemplo:\nui <- fluidPage(\n  fluidRow(\n    column(4, \n      # style = \"background-color: yellow;\",\n      \"Columna 1\"\n    ),\n    column(8, \n      # style = \"background-color: red;\",\n      \"Columna 2\"\n    )\n  ),\n  fluidRow(\n    column(6, \n      # style = \"background-color: blue;\",\n      \"Columna 3\"\n    ),\n    column(6, \n      # style = \"background-color: green;\",\n      \"Columna 4\"\n    )\n  )\n)\n\nserver <- function(input, output, session) {}\nCada fila está compuesta por 12 columnas.\n\n\n\n\n\n\n\n\n\nEsta sección queda de tarea para quienes asisten a este taller.\n\nA medida que creamos aplicaciones Shiny más complejas, resulta más complicado, o incluso ineficiente, mostrar todo su contenido dentro de una misma página.\nAnte esa problemática, la función tabPanel() nos permitirá crear la ilusión de múltiples páginas, para organizar mejor el contenido que se muestra de nuestra aplicación Shiny.\n\nLa función tabsetPanel() crea un contenedor para cualquier número de tabPanel(). Los tabPanel() funcionan como contenedores a parte de lo que queremos mostrar, de manera exclusiva, en la interfaz de usuario.\nEjemplo:\nui <- fluidPage(\n  tabsetPanel(\n    tabPanel(\"Subir datos\", \n      fileInput(\"archivo\", \"Datos\", buttonLabel = \"Cargar...\"),\n      textInput(\"delim\", \"Delimiador (deje vacío para adivinar)\"\",\"\")),\n      numericInput(\"skip\", \"Filas que saltear\", 0, min = 0),\n      numericInput(\"rows\", \"Filas que mostrar\", 10, min = 1)\n    ),\n    tabPanel(\"Fijar parámetros\")),\n    tabPanel(\"Visualizar resultados\")\n  )\n)\n\nserver <- function(input, output, session) {}\n\nPara no limitarnos a crear tabs de manera horizontal, pues sino estas podrían sobrepasar fácilmente el ancho de la pantalla, contamos con un par de alternativas:\n\nBarra de navegación: navbarPage() junto con navbarMenu().\nLista de navegación: navlistPanel().\n\nEjemplo de navlistPanel():\nui <- fluidPage(\n  navlistPanel(\n    id = \"tabset\",\n    \"Encabezado 1\",\n    tabPanel(\"panel 1\", \"Contenido del panel 1\"),\n    \"Encabezado 2\",\n    tabPanel(\"panel 2\", \"Contenido del panel 2\"),\n    tabPanel(\"panel 3\", \"Contenido del panel 3\")\n  )\n)\n\nserver <- function(input, output, session) {}\nEjemplo de navbarPage():\nui <- navbarPage(\n  \"Título\"\",\n  tabPanel(\"panel 1\", \"1\"),\n  tabPanel(\"panel 2\", \"2\"),\n  tabPanel(\"panel 3\", \"3\"),\n  navbarMenu(\"subpaneles\", \n    tabPanel(\"panel 4a\", \"4.a\"),\n    tabPanel(\"panel 4b\", \"4.b\"),\n    tabPanel(\"panel 4c\", \"4.c\")\n  )\n)\n\nserver <- function(input, output, session) {}\n\nBootstrap es un framework/librearía de CSS, que nos provee de plantillas para el diseño e interactividad de los elementos en nuestra página web.\nShiny nos permite emplear Bootstrap de la siguientes maneras:\n\nPersonalizar el diseño de la interfaz de usuario, vía bslib::bs_theme().\nEmplear el argumento/parámetro class para asignar diseños predeterminados por Bootstrap, a elementos de la interfaz de usuario; tal como hicimos en la primera sesión, para estilizar botones, guiándonos de esta chuleta de Bootstrap.\nReconfigurar el estilo de los componentes que Shiny nos proporciona para la interfaz de usuario, como en este ejemplo.\n\nTambién es posible emplear Shiny con frameworks de CSS distintos de Bootstrap, tales como shiny.semantic, shinyMobile (diseñado específicamente para aplicaciones móviles), shinymaterial y shinydashboard.\nAcá puede encontrar más opciones."
  },
  {
    "objectID": "chapter_06.html#temas",
    "href": "chapter_06.html#temas",
    "title": "\n4  Diseño, temas y HTML\n",
    "section": "\n4.2 Temas",
    "text": "4.2 Temas\nPara que no suceda que todas las aplicaciones Shiny tienen el mismo diseño, ya que por defauly funciona de manera aceptable, el paquete bslib nos permite personalizar fácilmente el diseño de nuestra app.\n\n4.2.1 Manos a la obra\nEl tema/modelo/plantilla de nuestra app se inicializa así:\nui <- fluidPage(\n  theme = bslib::bs_theme()\n)\n\n4.2.2 Temas de Shiny\nPodemos aplicar una plantilla de Bootstrap para toda la aplicación Shiny, vía el argumento bootswatch de bslib::bs_theme().\nEjemplo:\nui <- fluidPage(\n  theme = bslib::bs_theme(bootswatch = \"darkly\"),\n  sidebarLayout(\n    sidebarPanel(\n      textInput(\"txt\", \"Escribe algo:\", \"...\"),\n      sliderInput(\"deslizador\", \"Rango:\", 1, 100, 30)\n    ),\n    mainPanel(\n      h1(paste0(\"Tema: darkly\")),\n      h2(\"Encabezado 2\"),\n      p(\"lorem ipsum\")\n    )\n  )\n)\n\nserver <- function(input, output, session) {}\nPruebe cambiar el valor de bootswatch por \"united\", para visualizar los cambios al diseño.\nLa lista completa de los posibles valores para bootswatch puede obtenerse con el siguiente código:\nlibrary(bslib)\nbootswatch_themes(version = version_default(), full_path = FALSE)\nSino, aquí puede visualizar algunas de esos plantillas.\nPuedes crear una plantilla propia, de la siguiente manera:\nui <- fluidPage(\n  theme = bslib::bs_theme(\n    bg = \"#0b3d91\", \n    fg = \"white\", \n    base_font = \"Source Sans Pro\"\n  ),\n  sidebarLayout(\n    sidebarPanel(\n      textInput(\"txt\", \"Escribe algo:\", \"...\"),\n      sliderInput(\"deslizador\", \"Rango:\", 1, 100, 30)\n    ),\n    mainPanel(\n      h1(paste0(\"Tema: darkly\")),\n      h2(\"Encabezado 2\"),\n      p(\"lorem ipsum\")\n    )\n  )\n)\n\nserver <- function(input, output, session) {}\nAsimismo, Shiny te permite alterar de manera interactiva la plantilla usada para la aplicación, y guardar los cambios necesario a la plantilla, para poder actualizarla:\nEjemplo:\ntheme <- bslib::bs_theme(\n  bg = \"#0b3d91\", \n  fg = \"white\", \n  base_font = \"Source Sans Pro\"\n)\n\nui <- fluidPage(\n  bslib::bs_theme_preview(theme),\n  sidebarLayout(\n    sidebarPanel(\n      textInput(\"txt\", \"Escribe algo:\", \"...\"),\n      sliderInput(\"deslizador\", \"Rango:\", 1, 100, 30)\n    ),\n    mainPanel(\n      h1(paste0(\"Tema: darkly\")),\n      h2(\"Encabezado 2\"),\n      p(\"lorem ipsum\")\n    )\n  )\n)\n\nserver <- function(input, output, session) {}\n\n4.2.3 Temas para gráficos\nComo los diseños definidos en bslib::bs_theme() no afectan a los gráficos mostrados en la aplicación Shiny, se puede emplear el paquete thematic nos permite actualizar de manera automática los gráficos en la app, heredando el diseño definido en bslib::bs_theme().\nlibrary(shiny)\nlibrary(ggplot2)\nrequire(thematic)\n\nui <- fluidPage(\n  theme = bslib::bs_theme(bootswatch = \"darkly\"),\n  titlePanel(\"Gráfico con tema/plantilla\")),\n  plotOutput(\"plot\")\n)\n\nserver <- function(input, output, session) {\n  # thematic::thematic_shiny()\n  output$plot <- renderPlot({\n    ggplot(mtcars, aes(wt, mpg)) +\n      geom_point() +\n      geom_smooth()\n  }, res = 96)\n}\n\nshinyApp(ui, server)\n\n4.2.4 Detrás de la máscara\nEsta parte no la exploraremos todavía, ya que se tratará con mayor profundidad en la sesión 5, donde aprenderemos cómo Shiny nos permite una comunicación bilateral entre R y JavaScript.\nVeamos rápidamente esta sección del libro."
  },
  {
    "objectID": "chapter_06.html#resumen",
    "href": "chapter_06.html#resumen",
    "title": "\n4  Diseño, temas y HTML\n",
    "section": "\n4.3 Resumen",
    "text": "4.3 Resumen\nEn este capítulo aprendimos a estructur de manera más organizada el contenido de la interfaz de usuario de una aplicación Shiny. Asimismo, ahora sabemos que las funciones (de Shiny) de tipo input y output simplemente generan código HTML, el cual podemos estilizar por medio de Bootstrap."
  },
  {
    "objectID": "chapter_06.html#tarea",
    "href": "chapter_06.html#tarea",
    "title": "\n4  Diseño, temas y HTML\n",
    "section": "\n4.4 Tarea",
    "text": "4.4 Tarea\n\nResolver los ejercicios en esta sección del libro.\nRealizar de manera creativa el ejericio en esta sección."
  },
  {
    "objectID": "chapter_06.html#extra",
    "href": "chapter_06.html#extra",
    "title": "\n4  Diseño, temas y HTML\n",
    "section": "\n4.5 Extra",
    "text": "4.5 Extra\n\n\nUna manera deestructurar la interfaz de usuario en forma de malla."
  },
  {
    "objectID": "chapter_09.html",
    "href": "chapter_09.html",
    "title": "5  Cargas y descargas",
    "section": "",
    "text": "En este capítulo, exploraremos cómo Shiny nos permite realizar un análisis predeterminado de datos que cargamos a una aplicación Shiny; además de descargar data procesada o el resultado de un reporte parametrizado."
  },
  {
    "objectID": "chapter_09.html#carga",
    "href": "chapter_09.html#carga",
    "title": "5  Cargas y descargas",
    "section": "5.1 Carga",
    "text": "5.1 Carga\n\n5.1.1 Interfaz de usuario\nui <- fluidPage(\n  fileInput(id = \"carga\", label = \"Cargar un archivo\")\n)\n\n\n5.1.2 Función de servidor\nEjemplo de dataset: write.csv(iris,\"ruta_para_archivo/nombre.csv, row.names = FALSE)\n¿Qué valor asume fileInput() tras cargar un archivo?\nui <- fluidPage(\n  fileInput(\"upload\", NULL, Label = \"Upload...\", multiple = TRUE),\n  tableOutput(\"files\")\n)\nserver <- function(input, output, session) {\n  output$files <- renderTable(input$upload)\n}\n\nname: Nombre del archivo cargado.\nsize: Tamaño, en bytes, del archivo.\ntype: Especificación formal del tipo archivo cargado.\ndatapath: La data cargada se guarda en un folder temporal, con un nombre temporal. datapath es la ruta de tal data cargada al servidor.\n\n\n\n5.1.3 Cargar datos\n\ninput$upload vale NULL cuando se carga la página. Por ello, usaremos req(input$upload) para que su código relevante se ejecute cuando el archivo haya sido cargado.\nEl argumento accept es un intento de limitar qué tipo de archivos pueden añadirse para ser cargados. Obtendremos la extensión del archivo vía tools::file_ext().\n\nEjemplo:\nui <- fluidPage(\n  fileInput(\"upload\", NULL, accept = c(\".csv\", \".tsv\")),\n  numericInput(\"n\", \"Rows\", value = 5, min = 1, step = 1),\n  tableOutput(\"head\")\n)\n\nserver <- function(input, output, session) {\n  data <- reactive({\n    req(input$upload)\n    \n    ext <- tools::file_ext(input$upload$name)\n    switch(ext,\n      csv = vroom::vroom(input$upload$datapath, delim = \",\"),\n      tsv = vroom::vroom(input$upload$datapath, delim = \"\\t\"),\n      validate(\"Invalid file; Please upload a .csv or .tsv file\")\n    )\n  })\n  \n  output$head <- renderTable({\n    head(data(), input$n)\n  })\n}"
  },
  {
    "objectID": "chapter_09.html#descarga",
    "href": "chapter_09.html#descarga",
    "title": "5  Cargas y descargas",
    "section": "5.2 Descarga",
    "text": "5.2 Descarga\n\n5.2.1 Interfaz de usuario\nui <- fluidPage(\n  downloadButton(\"download1\"),\n  downloadLink(\"download2\")\n)\n\nserver <- function(input, output, session) {}\ndownloadButton() está asociado no una función de tipo render, sino a downloadHandler(), de la siguiente manera:\nui <- fluidPage(\n  downloadButton(\"download\")\n)\n\nserver <- function(input, output, session) {\n  output$download <- downloadHandler(\n    filename = function() {\n      paste0(input$dataset, \".csv\")\n    },\n    content = function(file) {\n      write.csv(data(), file)\n    }\n  )\n}\n\nfilename: Función sin argumentos que define el nombre del archivo por descargar.\ncontent: Función con único argumento file, la ruta donde se guardará el archivo.\n\n\n\n5.2.2 Descargar data\nui <- fluidPage(\n  selectInput(\"dataset\", \"Pick a dataset\", ls(\"package:datasets\")),\n  tableOutput(\"preview\"),\n  # downloadButton(\"download\", \"Download .tsv\")\n  downloadButton(\"download\", \"Download .csv\")\n)\n\nserver <- function(input, output, session) {\n  data <- reactive({\n    out <- get(input$dataset, \"package:datasets\")\n    if (!is.data.frame(out)) {\n      validate(paste0(\"'\", input$dataset, \"' is not a data frame\"))\n    }\n    out\n  })\n  \n  output$preview <- renderTable({\n    head(data())\n  })\n    \n  output$download <- downloadHandler(\n    filename = function() {\n      # paste0(input$dataset, \".tsv\")\n      paste0(input$dataset, \".csv\")\n    },\n    content = function(file) {\n      # vroom::vroom_write(data(), file)\n      write.csv(data(), file)\n    }\n  )\n}\n\n\n5.2.3 Descargar reportes\nPrimero, hay que definir qué es un reporte parametrizado, creado con R Markdown.\nui <- fluidPage(\n  sliderInput(\"n\", \"Number of points\", 1, 100, 50),\n  downloadButton(\"report\", \"Generate report\")\n)\n\nserver <- function(input, output, session) {\n  output$report <- downloadHandler(\n    filename = \"report.html\",\n    content = function(file) {\n      params <- list(n = input$n)\n      \n      id <- showNotification(\n        \"Rendering report...\", \n        duration = NULL, \n        closeButton = FALSE\n      )\n      on.exit(removeNotification(id), add = TRUE)\n\n      rmarkdown::render(\"report.Rmd\", \n        output_file = file,\n        params = params,\n        envir = new.env(parent = globalenv())\n      )\n    }\n  )\n}\nLa ruta del reporte parametrizado debe estar contenida dentro de la ruta de la aplicación Shiny que está siendo ejecutada."
  },
  {
    "objectID": "chapter_09.html#tarea",
    "href": "chapter_09.html#tarea",
    "title": "5  Cargas y descargas",
    "section": "5.3 Tarea",
    "text": "5.3 Tarea\nHacer los ejercicios 2 y 3 de esta sección."
  },
  {
    "objectID": "chapter_09.html#video-de-la-sesión",
    "href": "chapter_09.html#video-de-la-sesión",
    "title": "5  Cargas y descargas",
    "section": "5.4 Video de la sesión",
    "text": "5.4 Video de la sesión"
  },
  {
    "objectID": "sesion_04.html",
    "href": "sesion_04.html",
    "title": "6  Un ejemplo práctico",
    "section": "",
    "text": "En esta sesión, no exploraremos los capítulos del libro Mastering Shiny que se propuso en el sílabo, sino, realizaremos una serie de ejemplos prácticos donde aplicamos algunas de las herramientas aprendidas hasta ahora, además de cómo crear reportes parametrizados usando R Markdown.\nEl material para esta sesión lo puede encontrar vía este link."
  },
  {
    "objectID": "sesion_04.html#tarea",
    "href": "sesion_04.html#tarea",
    "title": "6  Un ejemplo práctico",
    "section": "6.2 Tarea",
    "text": "6.2 Tarea\n\nEmpezar a crear una aplicación Shiny de su interés propio, sin importar si es simple o no. Hay que practicar."
  },
  {
    "objectID": "sesion_04.html#video-de-la-sesión",
    "href": "sesion_04.html#video-de-la-sesión",
    "title": "6  Un ejemplo práctico",
    "section": "6.3 Video de la sesión",
    "text": "6.3 Video de la sesión"
  },
  {
    "objectID": "sesion_05.html",
    "href": "sesion_05.html",
    "title": "7  Shiny + R Markdown",
    "section": "",
    "text": "En esta última sesión (práctica) del taller, exploraremos una manera diferente de emplear Shiny. En particular, no vía archivos de tipo .R, donde separamos claramente la interfaz de usuario, de la función servidor; sino, principalmente, vía un único documento, y de tipo .Rmd ."
  },
  {
    "objectID": "sesion_05.html#motivación",
    "href": "sesion_05.html#motivación",
    "title": "7  Shiny + R Markdown",
    "section": "7.2 Motivación",
    "text": "7.2 Motivación\n¿Qué beneficios ganamos al emplear Shiny y R Markdown de manera conjunta?\n\nSintaxis más simple para introducir elementos Shiny a la página web.\nPoder crear reportes interactivos y/o parametrizados.\nVía el uso de chunks (bloques de código), es más sencillo organizar el código (sea de R, Python, CSS, JavaScript) de la aplicación, todo en un mismo documento de tipo .Rmd."
  },
  {
    "objectID": "sesion_05.html#proyectos-finales-del-taller",
    "href": "sesion_05.html#proyectos-finales-del-taller",
    "title": "7  Shiny + R Markdown",
    "section": "7.3 Proyectos finales del taller",
    "text": "7.3 Proyectos finales del taller\n\n7.3.1 Actualizar una base de datos asociada a una app Shiny\nEl codigo de este proyecto lo pueden encontrar en este link.\nBásicamente, emplearemos el paquete googlesheets4 de R para, luego de crear una hoja de cálculo usando Google Sheets, utilizar R con el fin de actualizar el contenido de dicha hoja de cálculo, actualizando así nuestra base de datos que se estará leyendo por medio de una aplicación Shiny.\n\nLinks relevantes:\n\nPágina de la librería googlesheets4.\nOtras maneras de guardar data de manera remota para una aplicación Shiny.\nEjemplo sobre guardar data remotamente, usando Google Sheets y Shiny.\n\n\n\n\n7.3.2 Creación de un reporte parametrizado\nEl codigo de este proyecto lo pueden encontrar en este link.\nNos familizaremos con R Markdown, empleándolo para crear un reporte que nos permita renderizarlo de manera automática, tras fijas ciertos parámetros para el reporte, y generar así automáticamente diversas versiones de un mismo reporte modelo que habremos creado.\n\n\n7.3.3 Creación de un dashboard interactivo\nEl codigo de este proyecto lo pueden encontrar en este link.\nEn este último proyecto del taller, combinaremos tres paquetes de R: R Mardkown junto a flexdashboard, para crear un dashboard; y, Shiny, para añadir interactividad a aquel dashboard.\nEsto con la finalidad de combinar ambos proyectos previos, dentro de una misma aplicación Shiny, cuya interfaz de usuario es un dashboard.\nEjemplos de dashboards creados con el paquete flexdashboard.\nResulta más sencillo (respecto a la sintaxis) utilizar elementos interactivos de Shiny, en documentos de tipo .Rmd, que de tipo .R. Entonces, pese a que es más común emplear el paquete shinydashboard, para crear dashboards interactivos con Shiny, nosotros utilizaremos el paquete flexdashboard para poder crear nuestro dashboard vía un archivo .Rmd.\nAclaro que, para convertir un archivo .Rmd con output de tipo html, a una aplicación Shiny, en general basta añadir runtime: shiny en el encabezado YAML del documento .Rmd. Esta combinación de R Markdown y Shiny no requiere del paquete flexdashboard.\n\nLinks relevantes:\n\nDocumentación del paquete flexdashboard.\nOtra solución a problema del botón de descarga de Shiny, cuando se usa con flexdashboard."
  },
  {
    "objectID": "sesion_05.html#publicar-una-aplicación-shiny-en-internet",
    "href": "sesion_05.html#publicar-una-aplicación-shiny-en-internet",
    "title": "7  Shiny + R Markdown",
    "section": "7.4 Publicar una aplicación Shiny en internet",
    "text": "7.4 Publicar una aplicación Shiny en internet\nLes recomiendo este tutorial sobre cómo subir a internet, por medio de una cuenta en shinyapps.io, una aplicación Shiny que hayas creado.\nPosiblemente requieran instalar el paquete rsconnect:\ninstalled.packages(\"rsconnect\")"
  },
  {
    "objectID": "sesion_05.html#comentarios-finales",
    "href": "sesion_05.html#comentarios-finales",
    "title": "7  Shiny + R Markdown",
    "section": "7.5 Comentarios finales",
    "text": "7.5 Comentarios finales\n\n7.5.1 Shiny + JavaScript\nSegún el sílabo, en esta sesión se exploraria cómo emplear de manera conjunta Shiny y JavaScript, pero, por motivos de tiempo, no se logró.\nAsí que, si les interesa ese tema de enorme potencial, el cual, resulta ser la razón por la que Shiny es mi paquete favorito de R, les recomiendo leer la sección Web Development with Shiny del libro JavaScript for R.\n\n\n7.5.2 Seguir estudiando Shiny\nSi les interesa seguir avanzando con el libro que hemos estado usando en este taller, Mastering Shiny, les recomiendo unirse a esta comunidad.\nEn es grupo, hay un club de lectura sobre el libro Mastering Shiny, y, hasta el 16 de agosto del 2022, se encuentran en el capítulo 15 del libro.\nSin embargo, a partir del capítulo 5 de ese mismo libro, estos capítulos no están tan relacionados entre si, así que no se pierden gran cosa por unirse tarde a tal club de lectura.\nTras este taller, ustedes ya tienen suficiente base en Shiny, como para profundizar en un nivel básico-intermedio de Shiny."
  },
  {
    "objectID": "sesion_05.html#tarea",
    "href": "sesion_05.html#tarea",
    "title": "7  Shiny + R Markdown",
    "section": "7.6 Tarea",
    "text": "7.6 Tarea\n\nAvanzar su proyecto personal del taller, para presentarlo el día miércoles 24 de agosto del 2022, en la última sesión de este taller."
  }
]